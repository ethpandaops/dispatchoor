# syntax=docker/dockerfile:1

# Build stage for React UI
FROM node:22-alpine AS builder

WORKDIR /app

# Copy package files first for better caching
COPY ui/package.json ui/package-lock.json ./
RUN npm ci

# Copy UI source and build
COPY ui/ ./
RUN npm run build

# Final stage with nginx
FROM nginx:alpine

# Install envsubst for runtime config substitution
RUN apk add --no-cache gettext

# Copy built UI files
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy nginx config template
# Uses dynamic resolver and variable-based proxy_pass for runtime DNS resolution
COPY <<'EOF' /etc/nginx/templates/default.conf.template
server {
    listen 80;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    # Dynamic DNS resolver (extracted from /etc/resolv.conf at startup)
    resolver ${RESOLVER} valid=10s ipv6=off;

    # Set API URL as variable for dynamic resolution at request time
    set $api_upstream "${API_URL}";

    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml text/javascript;

    # API proxy - using variable triggers runtime DNS resolution
    location /api/ {
        proxy_pass $api_upstream;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_read_timeout 86400;
    }

    location /health {
        proxy_pass $api_upstream;
        proxy_set_header Host $host;
    }

    location /metrics {
        proxy_pass $api_upstream;
        proxy_set_header Host $host;
    }

    # SPA fallback - serve index.html for all other routes
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
EOF

# Copy entrypoint scripts
COPY <<'EOF' /docker-entrypoint.d/40-envsubst-on-templates.sh
#!/bin/sh
set -e
# Extract resolver from /etc/resolv.conf (first nameserver)
# This works across Docker (127.0.0.11), Kubernetes (cluster DNS), and bare metal
RESOLVER=$(grep -m1 '^nameserver' /etc/resolv.conf | awk '{print $2}')
if [ -z "$RESOLVER" ]; then
    RESOLVER="127.0.0.11"  # Fallback for Docker
fi
export RESOLVER
echo "Using DNS resolver: $RESOLVER"
envsubst '${API_URL} ${RESOLVER}' < /etc/nginx/templates/default.conf.template > /etc/nginx/conf.d/default.conf
EOF

COPY <<'EOF' /docker-entrypoint.d/30-generate-ui-config.sh
#!/bin/sh
set -e

if [ "${ENABLE_PROXY:-false}" = "true" ]; then
    # Reverse proxy mode: use relative path (nginx proxies to backend)
    API_BASE="/api/v1"
else
    # Direct mode: browser connects directly to API
    # Strip trailing slash if present, then append /api/v1
    API_BASE="${API_URL%/}/api/v1"
fi

cat > /usr/share/nginx/html/config.json << CONFIGEOF
{
  "apiUrl": "${API_BASE}"
}
CONFIGEOF
chmod 644 /usr/share/nginx/html/config.json
echo "Generated config.json with apiUrl: ${API_BASE}"
EOF

RUN chmod +x /docker-entrypoint.d/40-envsubst-on-templates.sh /docker-entrypoint.d/30-generate-ui-config.sh

# Default: direct API access (browser connects directly to API)
# Set ENABLE_PROXY=true for reverse proxy mode (nginx proxies /api/* to backend)
ENV API_URL=http://localhost:9090
ENV ENABLE_PROXY=false

EXPOSE 80

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost/ || exit 1
